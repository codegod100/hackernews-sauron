use sauron::prelude::*;

fn main() {
    let md = r#"
I&#x27;d agree with some of the existing web APIs. But I think some web SQL API <i>should</i> be built-in.<p>Why? Because it&#x27;s a very common pattern. Almost fundamental. Take any project more complex than a toy calculator, and you&#x27;ll quickly find places where the authors are hand-rolling relational operations.<p>Does your app have an array of records in memory, which it then searches for values, filters by conditions, and&#x2F;or sorts? I&#x27;d give it a 50&#x2F;50 chance that if you replaced that array with an in-memory SQLite table, and all operations on it with SQL queries on it, the result would be less code, more readable code and better performance[0].<p>It&#x27;s not just the web - I&#x27;d argue that programming languages in general should all embed first-class in-memory relational database engines. It should be a part of the language standard - if it&#x27;s easy to write this:<p><pre><code>  struct Foo {\n    int bar;\n    date baz;\n    string quux;\n  };\n\n  &#x2F;&#x2F;somewhere in something\n  Array&lt;Foo&gt; foos;\n</code></pre>\nit should be easy to write this:<p><pre><code>  table&lt;Foo, index=[bar, quux]&gt; foos;\n</code></pre>\n(or some other, better way of describing intended data access patterns)<p>and get a thing that can be efficiently queried, filtered and transformed along dimensions specified, with the compiler turning your request into efficient bytecode&#x2F;nativecode. Doesn&#x27;t mean you have to write queries in vanilla SQL - there are more composable syntaxes out there. But arbitrary loops and map-reduces aren&#x27;t that good either.<p>When you start looking at your data processing code as database operations, you&#x27;ll see it everywhere. That map&#x2F;reduce&#x2F;zip blob? That&#x27;s a JOIN query. That struct you&#x27;re keeping in your event loop, that looks like:<p><pre><code>  struct Schedule {\n    Array&lt;Task&gt; tasks;\n    PQueue&lt;TaskId&gt; toRun;\n  };\n</code></pre>\nthat priority queue is an index on the tasks array, and looking at its front is just SELECT id FROM tasks ORDER BY priority LIMIT 1;. That Entity-Component-System pattern you&#x27;re using in your videogame? That&#x27;s <i>literally a relational database</i>. It was conceived of as such (and for massively multiplayer games, is often implemented as such). Wouldn&#x27;t it be nice if the ability to express this came built into the language? With a column-oriented option for improved performance, too?<p>--<p>[0] - It&#x27;s trivial to add indexes to SQL table. The engine will maintain them for you. Nobody habitually adds indexes to their own regular variables. They, along with the code to maintain them, would manifest as extreme code bloat. Meanwhile, in-memory SQLite is freakishly fast. If you&#x27;re measuring performance in Python&#x2F;Ruby units, you won&#x27;t even notice the FFI overhead.
"#;

    dbg!(&md);
    let node: Node<()> = sauron::markdown(md);
    let html = node.render_to_string();
    dbg!(html);
}
